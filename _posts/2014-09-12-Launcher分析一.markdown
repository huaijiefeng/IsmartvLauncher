---
layout: post
title:  "Launcher 源码分析一"
date:   2014-09-10 15:37:57
categories: jekyll update
---

{% highlight xml %}
 <application
     	android:name="com.android.launcher3.LauncherApplication"
        android:label="@string/application_name"
        android:icon="@mipmap/ic_launcher_home"
        android:hardwareAccelerated="true"
        android:largeHeap="@bool/config_largeHeap"
        android:supportsRtl="true">
</application>
{% endhighlight %}

`android:hardwareAccelerated`   
  为整个应用程序使用硬件加速.  

`android:largeHeap`    
  设置largeHeap可以增加内存的申请量.


{% highlight xml %}
 <activity
            android:name="com.android.launcher3.Launcher"
            android:launchMode="singleTask"
            android:clearTaskOnLaunch="true"
            android:stateNotNeeded="true"
            android:theme="@style/Theme"
            android:windowSoftInputMode="adjustPan"
            android:screenOrientation="nosensor">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.HOME" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.MONKEY"/>
            </intent-filter>
</activity>
{% endhighlight %}

`android:launchMode`

  `standard` Activity的默认加载方法，即使某个Activity在Task栈中已经存在，另一个activity通过Intent跳转到该activity，同样会新创建一个实例压入栈中。例如：现在栈的情况为：A B C D，在D这个Activity中通过Intent跳转到D，那么现在的栈情况为： A B C D D 。此时如果栈顶的D通过Intent跳转到B，则栈情况为：A B C D D B。此时如果依次按返回键，D  D C B A将会依次弹出栈而显示在界面上.
  
   `singleTop`  如果某个Activity的Launch mode设置成singleTop，那么当该Activity位于栈顶的时候，再通过Intent跳转到本身这个Activity，则将不会创建一个新的实例压入栈中。例如：现在栈的情况为：A B C D。D的Launch mode设置成了singleTop，那么在D中启动Intent跳转到D，那么将不会新创建一个D的实例压入栈中，此时栈的情况依然为：A B C D。但是如果此时B的模式也是singleTop，D跳转到B，那么则会新建一个B的实例压入栈中，因为此时B不是位于栈顶，此时栈的情况就变成了：A B C D B。
   
   `singleTask`  如果某个Activity是singleTask模式，那么Task栈中将会只有一个该Activity的实例。例如：现在栈的情况为：A B C D。B的Launch mode为singleTask，此时D通过Intent跳转到B，则栈的情况变成了：A B。而C和D被弹出销毁了，也就是说位于B之上的实例都被销毁了。

关于singleTask这个网上颇有争议，包括google api上的说明也让我看的是一头雾水，自己用实例亲测，终于算是搞清楚了

正解：1.singleTask 并不一定处于栈底

　　　2.singleTask 并一定会是栈底的根元素　

　　  3.singleTask 并不一定会启动新的task　　

情况一：如果在本程序中启动singleTask的activity：假设ActivityA是程序的入口，是默认的模式（standard）,ActivityB是singleTask 模式，由ActivityA启动，刚ActivityB不会位于栈底，不是根元素，不会启动新的task，此种情况ActivityB会和ActivityA在一个栈中，位于ActivityA上面

　　情况二：如果ActivityB由另外一个程序启动：假设apkA是情况一中的应用，apkB是测试程序，在apkB中启动apkA中的ActivityB，刚ActivityB会位于栈底，是根元素，会启动新的task

注意：singleTask模式的Activity不管是位于栈顶还是栈底，再次运行这个Activity时，都会destory掉它上面的Activity来保证整个栈中只有一个自己，切记切记

   `singleInstance`	  将Activity压入一个新建的任务栈中。例如：Task栈1的情况为：A B C。C通过Intent跳转到D，而D的Launch mode为singleInstance，则将会新建一个Task栈2。此时Task栈1的情况还是为：A B C。Task栈2的情况为：D。此时屏幕界面显示D的内容，如果这时D又通过Intent跳转到D，则Task栈2中也不会新建一个D的实例，所以两个栈的情况也不会变化。而如果D跳转到C，则栈1的情况变成了：A B C C，因为C的Launch mode为standard，此时如果再按返回键，则栈1变成：A B C。也就是说现在界面还显示C的内容，不是D。

好了，现在有一个问题就是这时这种情况下如果用户点击了Home键，则再也回不到D的即时界面了。如果想解决这个问题，可以为D在Manifest.xml文件中的声明加上：

 

<intent-filter>

<action android:name="android.intent.action.MAIN" />

<category android:name="android.intent.category.LAUNCHER" />

 </intent-filter>

 

加上这段之后，也就是说该程序中有两个这种声明，另一个就是那个正常的根activity，在打成apk包安装之后，在程序列表中能看到两个图标，但是如果都运行的话，在任务管理器中其实也只有一个。上面的情况点击D的那个图标就能回到它的即时界面（比如一个EditText，以前输入的内容，现在回到之后依然存在）。

 

PS：intent-filter中 <action android:name="android.intent.action.MAIN" />和 <category android:name="android.intent.category.LAUNCHER" />两个过滤条件缺一不可才会在程序列表中添加一个图标，图标下的显示文字是android:label设定的字符串。

`android:clearTaskOnLaunch`

`android:stateNotNeeded`  这个属性默认情况为false，若设为true，则当Activity重新启动时不会调用onSaveInstanceState（）方法，同样，onCreate（）方法中的Bundle参数将会用null值传进去，也就是说，Activity每次启动都跟第一次启动一样。这样，在某种特殊场合下，由于用户按了Home键，该属性设置为true时，可以保证不用保存原先的状态引用，节省了空间资源，从而可以让Activity不会像默认设置那样Crash掉。


`android:windowSoftInputMode`  活动的主窗口如何与包含屏幕上的软键盘窗口交互。这个属性的设置将会影响两件事情:

1>     软键盘的状态——是否它是隐藏或显示——当活动(Activity)成为用户关注的焦点。

2>     活动的主窗口调整——是否减少活动主窗口大小以便腾出空间放软键盘或是否当活动窗口的部分被软键盘覆盖时它的内容的当前焦点是可见的。

它的设置必须是下面列表中的一个值，或一个”state…”值加一个”adjust…”值的组合。在任一组设置多个值——多个”state…”values，例如＆mdash有未定义的结果。各个值之间用|分开。例如: <activity android:windowSoftInputMode="stateVisible|adjustResize" . . . >

在这设置的值(除"stateUnspecified"和"adjustUnspecified"以外)将覆盖在主题中设置的值

值 描述
 
"stateUnspecified" 软键盘的状态(是否它是隐藏或可见)没有被指定。系统将选择一个合适的状态或依赖于主题的设置。这个是为了软件盘行为默认的设置。
 
"stateUnchanged" 软键盘被保持无论它上次是什么状态，是否可见或隐藏，当主窗口出现在前面时。
 
"stateHidden" 当用户选择该Activity时，软键盘被隐藏——也就是，当用户确定导航到该Activity时，而不是返回到它由于离开另一个Activity。
 
"stateAlwaysHidden" 软键盘总是被隐藏的，当该Activity主窗口获取焦点时。
 
"stateVisible" 软键盘是可见的，当那个是正常合适的时(当用户导航到Activity主窗口时)。
 
"stateAlwaysVisible" 当用户选择这个Activity时，软键盘是可见的——也就是，也就是，当用户确定导航到该Activity时，而不是返回到它由于离开另一个Activity。
 
"adjustUnspecified" 它不被指定是否该Activity主窗口调整大小以便留出软键盘的空间，或是否窗口上的内容得到屏幕上当前的焦点是可见的。系统将自动选择这些模式中一种主要依赖于是否窗口的内容有任何布局视图能够滚动他们的内容。如果有这样的一个视图，这个窗口将调整大小，这样的假设可以使滚动窗口的内容在一个较小的区域中可见的。这个是主窗口默认的行为设置。
 
"adjustResize" 该Activity主窗口总是被调整屏幕的大小以便留出软键盘的空间。
 
"adjustPan" 该Activity主窗口并不调整屏幕的大小以便留出软键盘的空间。相反，当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分。这个通常是不期望比调整大小，因为用户可能关闭软键盘以便获得与被覆盖内容的交互操作。
 

`android.intent.action.MAIN`  它主要是决定我们程序的入口。因为我们的应用可能不止一个activity ,
但是在启动的时候应该启动哪个activity呢？就是则它决定的。

`android.intent.category.HOME`

`android.intent.category.DEFAULT`
  每一个通过 startActivity() 方法发出的隐式 Intent 都至少有一个 category，就是 "android.intent.category.DEFAULT"，所以只要是想接收一个隐式 Intent 的 Activity 都应该包括 "android.intent.category.DEFAULT" category，不然将导致 Intent 匹配失败。

`android.intent.category.MONKEY`













